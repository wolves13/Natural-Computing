\documentclass[runningheads]{llncs}

\usepackage{amsmath, amssymb}
\usepackage{enumitem}
\usepackage{wrapfig}
\usepackage{tikz}

\usetikzlibrary{shapes, arrows}
\usetikzlibrary{automata}
\usetikzlibrary{positioning}
\usetikzlibrary{lindenmayersystems}

\tikzstyle{mol} = [fill,circle,inner sep=1pt]
\tikzstyle{gridpoint} = [fill, circle, inner sep=1.5pt]

\newcommand{\east}{{\ensuremath \to}}
\newcommand{\se}{{\ensuremath \searrow}}

\DeclareMathOperator*{\argmin}{arg\,min}

\title{Towards the Algorithmic Molecular Self-Assembly of Fractals by Cotranscriptional Folding\thanks{This work is in part supported by 
JST Program to Disseminate Tenure Tracking System, MEXT, Japan, No.~6F36, 
by JSPS KAKENHI Grant-in-Aid for Young Scientists (A) No.~16H05854, 
and by JSPS and NRF under the Japan-Korea Basic Scientific Cooperation Program No. ????.
}}
\titlerunning{Algorithmic Self-Assembly of Fractals by Cotranscriptional Folding}
\author{
Yusei Masuda \and 
Shinnosuke Seki \and 
Yuki Ubukata
}
\institute{
Department of Computer and Network Engineering, 
The University of Electro-Communications, 
1-5-1, Chofugaoka, Chofu, Tokyo, 1828585, Japan 
\email{s.seki@uec.ac.jp}
}

\begin{document}

\maketitle

\begin{abstract}
RNA cotranscriptional folding has been just experimentally proven capable of self-assembling a rectangular tile at nanoscale {\it in vivo} (RNA origami). 
We initiate the theoretical study on the algorithmic self-assembly of shapes by cotranscriptional folding using a novel computational model called the oritatami system. 
We propose an oritatami system that folds into an arbitrary finite portion of the Heighway dragon fractal, also-known as the paperfolding sequence $P = {\rm RRLRRLLR} \cdots$. 
The $i$-th element of $P$ can be obtained by feeding $i$ in binary to a 4-state DFA with output (DFAO). 
We implement this DFAO and a bit-sequence bifurcator as modules of oritatami system. 
Combining them with a known binary counter yields the proposed system. 
\end{abstract}

%--------------------------------------------------------------------------------------------------------
	\section{Introduction}
%--------------------------------------------------------------------------------------------------------

An RNA sequence, over nucleotides of four kinds {\tt A}, {\tt C}, {\tt G}, {\tt U}, is synthesized (\textit{transcribed}) from its template DNA sequence over {\tt A}, {\tt C}, {\tt G}, {\tt T} nucleotide by nucleotide by an RNA polymerase (RNAP) enzyme according to the one-to-one mapping ${\tt A} \to {\tt U}$, ${\tt C} \to {\tt G}$, ${\tt G} \to {\tt C}$, and ${\tt T} \to {\tt A}$ (for details, see, e.g., \cite{AJLMRRW2014}). 
The yield, called \textit{transcript}, starts folding immediately after it emerges from RNAP. 
This is the \textit{cotranscriptional folding} (see Fig.~\ref{fig:rna_origami}). 
Geary, Rothemund, and Andersen have recently demonstrated the capability of cotranscriptional folding to self-assemble an RNA molecule of an intended shape at nano-scale \cite{GearyRothemundAndersen2014}. 
They actually proposed an architecture of a DNA sequence whose transcript folds cotranscriptionally into an RNA tile of specific rectangular shape highly likely \textit{in vitro}. 

\begin{figure}[tb]
\centering
\includegraphics[width=0.8\linewidth]{Figs/rna_origami.pdf}
\caption{RNA cotranscriptional folding. 
An RNA polymerase attaches to a template DNA sequence (gray spiral), scans it through, and synthesizes its RNA copy. 
The RNA sequence begins to fold upon itself immediately as it emerges from polymerase. 
}
\label{fig:rna_origami}
\end{figure}

Algorithms and computation are fundamental to molecular self-assembly as illustrated in an enormous success of their use in DNA tile self-assembly (see, e.g., \cite{Doty2012,Patitz2016,WinfreePhD} and references therein). 
The Sierpinski triangle fractal was algorithmically self-assembled even \textit{in vitro} from coalescence of DNA tiles that compute XOR \cite{RothemundPapadakisWinfree2004}. 
Cotranscriptional folding exhibits highly sophisticated computational and algorithmic behaviors as well. 
Indeed, fluoride riboswitches in \textit{Bacillus cereus} bacteria cotranscriptionally fold into a terminator stem or do not, in order to regulate gene expression \cite{WaStYuLiLu2016}. 
This is just one example but should be enough to signify both the context-sensitivity of cotranscriptional folding and shapes thus self-assembled. 
Geary et al.~have proved the capability of context-sensitivity to count in binary using a novel mathematical model of cotranscriptional folding called \textit{oritatami system} (abbreviated as OS) \cite{GeMeScSe2016}. 

\begin{figure}[tb]
\centering
\begin{minipage}{0.35\linewidth}
\centering
\scalebox{0.7}{\begin{tikzpicture}[>=latex, node distance=2cm, initial text=, bend angle=15]
	\tikzstyle{every initial by arrow} = [->, double];

	\node [state, initial, thick] (q_0)                        {$q_0/R$};
	\node [state, thick]                     (q_1) [right of = q_0]  {$q_1/R$};
	\node [state, thick]                     (q_2) [below right of = q_1] {$q_2/L$};
	\node [state, thick]                     (q_3) [above right of = q_1] {$q_3/R$};

	\path [thick, ->] (q_0) edge [right] node [above]              {$0$}                 (q_1)
         		         edge [loop above] node [above]             {$1$}               ()
         			   (q_1) edge [bend left] node [above]             {$0$}                 (q_3)
         		         edge [bend right] node [below]             {$1$}              (q_2)
         			   (q_2)  edge [loop above] node [above]             {$0,1$}               ()
         			   (q_3)  edge [loop above] node [above]             {$0,1$}               ();
\end{tikzpicture}}
\end{minipage}
\begin{minipage}{0.05\linewidth}
\ \\
\end{minipage}
\begin{minipage}{0.55\linewidth}
\centering
\scalebox{0.035}{\begin{tikzpicture}
  \draw[ultra thick, blue!50!black,rotate=270,l-system={rule set={X->X-YF,Y->FX+Y},
  step=100pt,angle=90,axiom=FX,order=10},-triangle 90] l-system;
\end{tikzpicture}}
\end{minipage}
\caption{
(Left) DFAO to output the direction (L/R) of $i$-th turn of the Heighway dragon given $i \ge 0$ in binary from the LSB. 
(Right) The first $2^{10}{-}1$ turns of the dragon. 
}
\label{fig:heighway_dragon}
\end{figure}

We shall initiate theoretical study on algorithmic self-assembly of shapes by cotranscriptional folding using oritatami system. 
Sierpinski triangle would allow our study to borrow rich insights from the DNA tile self-assembly. 
However, in order to cut directly to the heart of algorithmic self-assembly by cotranscriptional folding, shapes of choice should be traversable somehow algorithmically. 
One such way is to feed a turtle program (see \cite{AbelsondiSessa1981}) with an \textit{automatic sequence} as commands (drawing a line segment, rotation, etc.), whose $i$-th bit can be obtained by giving $i$ in binary from the least significant bit (LSB) to one DFA with output (DFAO) \cite{AlloucheShallit2003}.
Shapes thus describable include the Heighway dragon \cite{AlloucheShallit2003} and von Koch curve \cite{MaHoldener2005}. 
A DFAO for the Heighway dragon is illustrated in Fig.~\ref{fig:heighway_dragon}. 
It outputs the following sequence, given $i = 0, 1, 2, \ldots$ in binary: 
\[
P 	= {\rm RRLRRLLRRRLLRLLRRRLRRLLLRRLLRLL} \cdots.
\]
(The notation $P$ is after its appellative \textit{paperfolding sequence} \cite{AlloucheShallit2003}.) 
For instance, given $i = 2$ in binary from the LSB as 01, the DFAO transitions as $q_0 \to q_1 \to q_2$ and hence $P[2] = {\rm L}$. 
A turtle should interpret an L (resp.~R) as ``move forward by unit distance and turn left (resp. right) 90 degrees.''
Any portion of the dragon can be represented by a factor of $P$; for instance, Fig.~\ref{fig:heighway_dragon} (Right) depicts the portion $P[0 .. 1022]$, i.e., the first $2^{10}-1$ turns of the dragon. 

\begin{wrapfigure}{l}{0.5\linewidth}
\vspace*{-5mm}
\centering
\includegraphics[width=\linewidth]{Figs/6bit_heighway.pdf}
\caption{The portion $P[0 .. 62]$ of the Heighway dragon folded by the proposed OS.}
\label{fig:heighway6_oritatami}
\vspace*{-5mm}
\end{wrapfigure}

In this paper, we propose a generic design of oritatami system for the algorithmic cotranscriptional folding of an arbitrary finite portion of the Heighway dragon. 
Fig.~\ref{fig:heighway6_oritatami} shows the portion $P[0 .. 62]$ thus folded (the dragon is slanted but this is because the OS operates on the triangular grid rather than on the square grid). 
The OS transcribes three modules: counter module, DFAO module, and turning module, in this order repeatedly. 
The counter module is a technical modification of the binary counter proposed in \cite{GeMeScSe2016} so that it increments a given count $i$ exactly by 1 while folding into a line segment. 
At the end of the segment comes a DFAO module, which computes the turn direction $P[i]$ and propagates it along with the count $i$ to the next module for turn.  
An L-shaped block is the turning module. 
It is a concatenation of three bit-sequence bifurcators, each of which folds into a rhombus, bifurcates $i$ leftward as well as rightward, and guides further folding according to the turning direction. 
The next counter module then again increments one of the bifurcated $i$ and folds into the next line segment, and so on. 

The generic design proves the next theorem (for terminologies, see Sect.~\ref{sect:preliminaries}). 

\begin{theorem}\label{thm:main}
	For any finite portion $P[i..j]$ of the Heighway dragon, there exist a scaling factor $c \in \mathbb{N}^+$ and a cyclic deterministic oritatami system of delay 3 and arity 3 that weakly folds into the $c$-rhombus scaling of $P[i..j]$. 
\end{theorem}

\noindent
A JavaScript program to run this OS is available at {\small {\tt https://wolves13.github.io}}. 

%--------------------------------------------------------------------------------------------------------
	\section{Preliminaries}
	\label{sect:preliminaries}
%--------------------------------------------------------------------------------------------------------

\begin{wrapfigure}[9]{l}{0.3\linewidth}
\vspace*{-7mm}
\scalebox{0.7}{\begin{tikzpicture}
\foreach \x in {0, 1, 2, 3} {
	\foreach \y in {0, 1, 2} {
		\draw (\x, 0)++(120:\y) node[gridpoint]{}; 
	}
}
\draw[-latex] (-0.5, 0) -- ++(0:4) node[below] {$x$};
\draw[-latex] (0, 0) node[below left] {O} ++(300:0.5)-- ++(120:3) node[right] {$y$};

\end{tikzpicture}}
\caption{Triangular grid graph $\mathbb{T}$ with the $(x, y)$-coordinate and the origin.}
\label{fig:triangular_grid}
\end{wrapfigure}

Let $\Sigma$ be a set of types of abstract molecules, or \textit{beads}, and $\Sigma^*$ be the set of finite sequences of beads. 
A bead of type $a \in \Sigma$ is called an $a$-bead. 
Let $w = b_1 b_2\cdots b_n \in \Sigma^*$ be a string of length $n$ for some integer $n$ and bead types $b_1, \ldots, b_n \in \Sigma$.
The \textit{length} of $w$ is denoted by $|w|$, that is, $|w| = n$. 
For two indices $i,j$ with $1\leq i \leq j \leq n$, we let $w[i..j]$ refer to the subsequence $b_i b_{i+1} \cdots b_{j-1} b_{j}$; if $i=j$, then we simplify $w[i..i]$ as $w[i]$.
For $k \ge 1$, $w[1..k]$ is called a \textit{prefix} of $w$. 

Oritatami systems fold their transcript, a sequence of beads, over the triangular grid graph $\mathbb{T} = (V, E)$ (see Figs.~\ref{fig:triangular_grid} and \ref{fig:glider}) cotranscriptionally based on hydrogen-bond-based interactions (\textit{h-interactions} for short) which the system allow for between adjacent beads of particular types. 
When beads form an h-interaction, informally we say they are bound. 
For two points $p_1 = (x_1, y_1), p_2 = (x_2, y_2) \in V$, $\{p_1, p_2\} \in E$ if $|x_1 - x_2| = 1$ and $y_1 = y_2$ or $x_1 = x_2$ and $|y_1 - y_2| = 1$. 
A directed path $P = p_1 p_2 \cdots p_n$ in $\mathbb{T}$ is a sequence of \textit{pairwise-distinct} points $p_1, p_2, \ldots, p_n \in V$ such that $\{p_i, p_{i+1}\} \in E$ for all $1 \leq i < n$.
Its $i$-th point is referred to as $P[i]$. 
A \textit{conformation} $C$ is a triple $(P, w, H)$ of a directed path $P$ in $\mathbb{T}$, $w \in \Sigma^*$ of the same length as $P$, and a set of h-interactions $H \subseteq \{\{i,j\} \mid 1 \leq i, i+2 \leq j, \{P[i], P[j]\} \in E\}$.
This is to be interpreted as the sequence $w$ being folded in such a manner that its $i$-th bead $w[i]$ is placed on the $i$-th point $P[i]$ along the path and the $i$-th and $j$-th beads are bound if and only if $\{i, j\} \in H$. 
The condition $i+2 \leq j$ represents the topological restriction that two consecutive beads along the path cannot be bound.
A \textit{rule set} $\mathcal{H} \subseteq \Sigma \times \Sigma$ is a symmetric relation over the set of pairs of bead types, that is, for all bead types $a, b \in \Sigma$, $(a, b) \in \mathcal{H}$ implies $(b, a) \in \mathcal{H}$. 
An h-interaction $\{i, j\} \in H$ is \textit{valid with respect to $\mathcal{H}$}, or simply \textit{$\mathcal{H}$-valid}, if $(w[i], w[j]) \in \mathcal{H}$. 
This conformation $C$ is $\mathcal{H}$-valid if all of its h-interactions are $\mathcal{H}$-valid. 
For an integer $\alpha \ge 1$, $C$ is \textit{of arity $\alpha$} if it contains a bead that forms $\alpha$ h-interactions and no bead of $C$ forms more. 
By $\mathcal{C}_{\le \alpha}$, we denote the set of all conformations of arity at most $\alpha$.

Oritatami systems grow conformations by elongating them under their own rule set. 
Given a rule set $\mathcal{H}$ and an $\mathcal{H}$-valid finite conformation $C_1 = (P, w, H)$, 
we say that another conformation $C_2$ is an \textit{elongation of} $C_1$ \textit{by a bead} $b \in \Sigma$, written as $C_1 \xrightarrow{\mathcal{H}}_b C_2$, if $C_2 = (Pp, wb, H \cup H')$ for some point $p$ not along the path $P$ and set of h-interactions $H' \subseteq \left\{ \{i, |w|+1\} \bigm| 1\leq i < |w|, \{P[i], p\} \in E, (w[i], b) \in \mathcal{H}\right\}$, which can be empty.
Note that $C_2$ is also $\mathcal{H}$-valid.
This operation is recursively extended to the elongation by a finite sequence of beads as: 
for any conformation $C$, $C \xrightarrow{\mathcal{H}}^*_\lambda C$; 
and for a finite sequence of beads $w \in \Sigma^*$ and a bead $b \in \Sigma$,
a conformation $C_1$ is elongated to a conformation $C_2$ by $wb$,
written as $C_1 \xrightarrow{\mathcal{H}}^*_{wb} C_2$, if there is a conformation $C'$ that satisfies
$C_1 \xrightarrow{\mathcal{H}}^*_w C'$ and $C' \xrightarrow{\mathcal{H}}_b C_2$.

A finite \textit{oritatami system} (OS) is a 5-tuple $\Xi = (\mathcal{H}, \alpha, \delta, \sigma,w)$, where 
$\mathcal{H}$ is a rule set,
$\alpha$ is an arity, 
$\delta \geq 1$ is a parameter called the \textit{delay}, 
$\sigma$ is an initial $\mathcal{H}$-valid conformation of arity $\alpha$ called the \textit{seed}, upon which its finite \textit{transcript} $w \in \Sigma^*$ is to be folded by stabilizing beads of $w$ one at a time so as to minimize energy collaboratively with the succeeding $\delta -1$ nascent beads. 
The energy of a conformation $C = (P, w, H)$, denoted by $\Delta G(C)$, is defined to be $-|H|;$ the more h-interactions a conformation has, the more stable it gets.
The set $\mathcal{F}(\Xi)$ of conformations \textit{foldable} by this system is recursively defined as: 
the seed $\sigma$ is in $\mathcal{F}(\Xi)$; and provided that an elongation $C_{i}$ of $\sigma$ by the prefix $w[1..i]$ be foldable (i.e., $C_0 = \sigma$), its further elongation $C_{i+1}$ by the next bead $w[i+1]$ is foldable if
\begin{equation}\label{eq:cotranscriptional_folding}
C_{i+1} \in \argmin_{
\substack{
C \in \mathcal{C}_{\le \alpha} s.t. \\
C_i \xrightarrow{\mathcal{H}}_{w[i+1]}C \\
}
}
\min \Big\{ \Delta G(C') \mid 
C \xrightarrow{\mathcal{H}}^*_{w[i+2...i+k]}C', k\le \delta, C' \in \mathcal{C}_{\le \alpha}
\Big\}.
\end{equation}
We say that the bead $w[i+1]$ and the h-interactions it forms are \textit{stabilized} according to $C_{i+1}$.
Note that an arity-$\alpha$ OS cannot fold any conformation of arity larger than $\alpha$.
A conformation foldable by $\Xi$ is \textit{terminal} if none of its elongations is foldable by $\Xi$. 
The OS $\Xi$ is \textit{deterministic} if for all $i \ge 0$, there exists at most one $C_{i+1}$ that satisfies \eqref{eq:cotranscriptional_folding}. 
The deterministic OS is abbreviated as DOS. 
Thus, a DOS folds into a unique terminal conformation. 
An OS is \textit{cyclic} if its transcript is of the form $u^i u_p$ for some $i \ge 2$ and a prefix $u_p$ of $u$. 
The cyclic OS is considered to be one of the practical classes of OS because a periodic RNA transcript is likely to be transcribed out of a circular DNA sequence \cite{GearyAndersen2014}. 

\begin{wrapfigure}{r}{0.6\linewidth}
\vspace*{-7mm}
\centering
\scalebox{0.4}{\begin{tikzpicture}

\foreach \x in {0, 4, 8, 13} {
\draw[thick, red] (\x, 0) node[mol] {} node[above] {\Large $a$}
-- ++(300:1) node[mol] {} 
-- ++(240:1) node[mol] {} node[below] {\Large $b'$}
-- ++(0:1) node[mol] {} node[below] {\Large $b$}
-- ++(60:1) node[mol] {} 
-- ++(120:1) node[mol] {} node[above] {\Large $a'$}
;
\draw[thick, dashed,red] (\x, 0) -- ++(0:1);
}

\draw[cyan, -latex] (1, 0) -- ++(120:1) node[mol] {} node[above] {\Large $a$} -- ++(180:1) node[mol]{} -- ++(240:1) node[mol] {} node[above] {\Large $b'$};
\draw[cyan, -latex] (1, 0) -- ++(60:1) node[mol] {} node[above] {\Large $a$} -- ++(0:1) node[mol] {} -- ++(300:1) node[mol] {} node[right] {\Large $b'$};
\draw[ultra thick, cyan, -latex] (1, 0) -- ++(0:1) node[mol] {} node[above] {\huge $a$} -- ++(300:1) node[mol] {} -- ++(240:1) node[mol] {} node[below] {\huge $b'$};

\draw[dashed, cyan] (0,0)++(300:2) -- ++(0:1);

\draw (3,0)++(300:1) node {\Large $\Rightarrow$};
\draw (7,0)++(300:1) node {\Large $\Rightarrow$};
\draw (12,0)++(300:1) node {\Large $\Rightarrow$};


\draw[thick, -latex] (5, 0) -- ++(0:1) node[mol] {} node[above] {\Large $a$};

\draw[cyan, -latex] (6, 0) -- ++(300:1) node[mol] {} -- ++(240:1) node[mol] {} node[below] {\Large $b'$} -- ++(0:1) node[mol] {} node[below] {\Large $b$};
\draw[cyan, -latex] (5,0)++(300:2)++(240:0.3) -- ++(240:0.7) node[mol] {} node[below] {\Large $b$};
\draw[cyan, -latex] (5,0)++(300:2.3) -- ++(300:0.7) node[mol] {} node[below] {\Large $b$};
\draw[dashed, cyan] (4,0)++(300:2) -- ++(0:1);


\draw[thick, -latex] (9, 0) -- ++(0:1) node[mol] {} node[above] {\Large $a$}
-- ++(300:1) node[mol] {}
;
\draw[cyan, -latex] (10,0)++(300:1) -- ++(240:1) node[mol] {} node[below] {\Large $b'$}
-- ++(240:1) node[mol] {} node[below] {\Large $b$}
-- ++(180:1) node[mol] {}
;
\draw[cyan, -latex] (9,0)++(300:2) -- ++(0:1) node[mol] {} node[below] {\Large $b$} -- ++(60:1) node[mol] {};
\draw[cyan, -latex] (10,0)++(300:1) -- ++(60:1) node[mol] {} node[right] {\Large $b'$}
-- ++(120:1) node[mol] {} node[above] {\Large $b$}
-- ++(180:1) node[mol] {}
;
\draw[cyan,dashed] (8,0)++(300:2) -- ++(0:1);

\draw[thick, -latex] (14, 0) -- ++(0:1) node[mol] {} node[above] {\Large $a$}
-- ++(300:1) node[mol] {}
-- ++(240:1) node[mol] {} node[below] {\Large $b'$}
;
\draw[dashed] (13,0)++(300:2) -- ++(0:1);
\draw[cyan, -latex] (14,0)++(300:2) -- ++(0:1) node[mol] {} node[below] {\Large $b$}
-- ++(60:1) node[mol] {}
-- ++(120:1) node[mol] {} node[above] {\Large $a'$}
;
\draw[cyan,dashed] (15,0) -- ++(0:1);

\end{tikzpicture}}
\vspace*{-2mm}
\caption{Progression of a glider by distance 1.}
\label{fig:glider}
\vspace*{-5mm}
\end{wrapfigure}

Let us provide an example of cyclic DOS that folds into a useful \textit{glider} motif. 
Consider a delay-3 OS whose transcript $w$ is a repetition of $a \bullet b' b \bullet a'$ and whose rule set is $\mathcal{H} = \{(a, a'), (b, b')\}$, making $\bullet$-beads inert. 
Its seed, colored in red in Fig.~\ref{fig:glider}, can be elongated by the first three beads $w[1..3] = a \bullet b'$ in various ways, only three of which are shown in Fig.~\ref{fig:glider} (left). 
Only $w[3] = b'$ can form a new h-interaction, with the $b$ in the seed (according to $\mathcal{H}$, the first $a$ is also capable of binding, with $a'$, but the sole $a'$ around is just ``too close''). 
For the $b{-}b'$ binding, $w[1..3]$ must be folded as bolded in Fig.~\ref{fig:glider} (left). 
According to this most stable ``bolded'' elongation, the bead $w[1] = a$ is stabilized to the east of the previous bead. 
Then $w[4] = b$ is transcribed. 
We can easily check that no matter how $w[2..4]$ is folded, $b'$-beads around are either too far or too close for $w[4]$ to bind to. 
Hence, $w[4]$ cannot override the previous ``decision'' so that $w[2]$ is stabilized as bolded. 
$w[5]$ cannot override it, either, simply because it is inert. 
It is easily induced inductively that gliders of arbitrary ``flight distance'' can be folded. 

Gliders also provide a medium to propagate 1-bit arbitrarily far as the position of their last beads, which is determined by the height (top or bottom) of the first bead and a propagating distance.  
For instance, the glider in Fig.~\ref{fig:glider} launches top and thus its last bead (the $a'$) also comes top after traveling the distance 2.
The OS we shall propose exploits this information-carrying capability.

Assume the $(x, y)$-coordinate over $\mathbb{T} = (V, E)$ as shown in Fig.~\ref{fig:triangular_grid}. 
A \textit{shape} $S$ is a set of points in $V$. 
For an integer $c \ge 1$, let $Rhomb_c = \{(x, y) \in V \mid x, y \le c\}$.
Let $S' = \{(cx, cy) \mid (x, y) \in S\}$. 
The \textit{$c$-rhombus scaling} of $S$, denoted by $\diamondsuit_c(S)$, is the union over all $\vec{p} \in S'$ of sets of points $Rhomb_c + \vec{p} = \{\vec{v} \in V \mid \mbox{$\vec{v} = \vec{r} + \vec{p}$ for some $\vec{r} \in Rhomb_c$}\}$.
We say that an OS $\Xi$ \textit{weakly folds} (or ``self-assembles'') $\diamondsuit_c(S)$ if every terminal assembly of $\Xi$ puts at least one bead in $Rhomb_c + \vec{p}$ for all $\vec{p} \in S'$ and no bead in $Rhomb_c + \vec{q}$ for all $\vec{q} \not\in S'$. 

%--------------------------------------------------------------------------------------------------------
	\section{Folding the $n$-bit Heighway dragon}
%--------------------------------------------------------------------------------------------------------

We propose a generic design of DOS that allows us to fold an arbitrary finite portion $P[j_1 .. j_2]$ of the slanted Heighway dragon. 
Independently of $j_1, j_2$, both delay and arity are set to 3 and 567 bead types\footnote{Some of the bead types might be saved but not easily due to the NP-hardness of minimizing the number of bead types \cite{HanKim2017}.} \texttt{1}, \texttt{2}, \dots, \texttt{567} with a fixed rule set $\mathcal{H}$ are employed. 
The design also challenges to make the resulting DOS cyclic. 
Otherwise, one could simply implement left and right-turn modules and concatenate their copies according to the (non-periodic) sequence $P$. 
However, it is highly unlikely that an OS for the infinite Heighway dragon, if any, could adopt this approach in order to be describable by a finite mean. 
Such a ``hardcoding'' also runs counter to the spirit of algorithmic self-assembly. 

\begin{figure}[tb]
\centering
\scalebox{0.8}{\begin{tikzpicture}

\foreach \x in {0} {
\draw (\x, 0)++(120:1.5) -- ++(0:1) -- ++(300:0.5) -- ++(180:0.5) node (seedout) {} -- ++(180:0.5) -- cycle;
\draw[white] (\x, 0)++(120:1.25) -- node[black] {Seed} ++(0:1);
}

\foreach \x in {0} {
\draw (\x, 0) -- ++(0:0.5) node (C1in) {} -- ++(0:0.5) -- node[sloped, below] {Counter $C$} ++(300:3) -- ++(180:0.5) node (C1out) {} -- ++(180:0.5) -- node[sloped, above] {$i{+}{+}$ if carried} ++(120:3); 
}

\foreach \x in {2} {
\draw (\x, 0)++(300:1) -- ++(0:0.5) node (Dvin) {} -- ++(0:0.5) -- ++(300:0.5) -- ++(180:0.5) node (Dvout) {} -- ++(180:0.5) -- cycle; 
\draw[white] (\x, 0)++(300:1.25) -- node[black] {$D_v$} ++(0:1);
}

\foreach \x in {7} {
\draw[thick, ->] (\x, 0) -- ++(0:0.4) node (O1in) {} -- ++(0:0.4) -- ++(300:0.1) -- ++(180:0.8) -- ++(300:0.1)
-- ++(0:0.8) -- ++(300:0.1) -- ++(180:0.8) -- ++(300:0.1)
-- ++(0:0.8) -- ++(300:0.1) -- ++(180:0.8) -- ++(300:0.1)
-- ++(0:0.8) -- ++(300:0.1) -- ++(180:0.8) -- ++(300:0.1)
-- ++(0:0.9) -- ++(120:0.8) -- ++(0:0.2)
;
\draw[thick, ->] (\x+1.1, 0) 
-- ++(300:0.8) -- ++(0:0.1) -- ++(120:0.8) -- ++(0:0.1)
-- ++(300:0.8) -- ++(0:0.1) -- ++(120:0.8) -- ++(0:0.1)
-- ++(300:0.8) -- ++(0:0.1) -- ++(120:0.8) -- ++(0:0.1)
-- ++(300:0.8) -- ++(0:0.1) -- ++(120:0.8) -- ++(0:0.1)
-- ++(300:0.9) -- ++(180:0.8) -- ++(300:0.2)
;
\draw[thick, ->] (\x+1.1, 0)++(300:1.1) -- ++(0:0.8) -- ++(300:0.1) -- ++(180:0.8) -- ++(300:0.1)
-- ++(0:0.8) -- ++(300:0.1) -- ++(180:0.8) -- ++(300:0.1)
-- ++(0:0.8) -- ++(300:0.1) -- ++(180:0.8) -- ++(300:0.1)
-- ++(0:0.8) -- ++(300:0.1) -- ++(180:0.8) -- ++(300:0.1)
-- ++(0:0.9) -- ++(120:0.8) -- ++(0:0.2) node (O1out) {}
;
}

\foreach \x in {5} {
\draw[thick, ->] (\x, 0) -- ++(0:0.4) node (A1in) {} -- ++(0:0.4) -- ++(300:0.1) -- ++(180:0.8) -- ++(300:0.1)
-- ++(0:0.8) -- ++(300:0.1) -- ++(180:0.8) -- ++(300:0.1)
-- ++(0:0.8) -- ++(300:0.1) -- ++(180:0.8) -- ++(300:0.1)
-- ++(0:0.8) -- ++(300:0.1) -- ++(180:0.8) -- ++(300:0.1)
-- ++(0:0.8) -- ++(300:0.1) -- ++(180:1)
;
\draw[thick,->] (\x,0)++(300:0.9)++(180:0.2) 
-- ++(120:0.8) -- ++(180:0.1) -- ++(300:0.8) -- ++(180:0.1)
-- ++(120:0.8) -- ++(180:0.1) -- ++(300:0.8) -- ++(180:0.1)
-- ++(120:0.8) -- ++(180:0.1) -- ++(300:0.8) -- ++(180:0.1)
-- ++(120:0.8) -- ++(180:0.1) -- ++(300:0.8) -- ++(180:0.1)
-- ++(120:0.8) -- ++(180:0.1) -- ++(300:1)
;
\draw[thick, ->] (\x-1.1, 0)++(300:1.1) -- ++(0:0.8) -- ++(300:0.1) -- ++(180:0.8) -- ++(300:0.1)
-- ++(0:0.8) -- ++(300:0.1) -- ++(180:0.8) -- ++(300:0.1)
-- ++(0:0.8) -- ++(300:0.1) -- ++(180:0.8) -- ++(300:0.1)
-- ++(0:0.8) -- ++(300:0.1) -- ++(180:0.8) -- ++(300:0.1)
-- ++(0:0.8) -- ++(300:0.1) -- ++(180:1) node (A1out) {}
;
}

\draw(6.5, 0)++(300:1.5) node {Turning module $T$};

\foreach \x in {5.5} {
\draw (\x, 0)++(300:5) -- node[below] {Counter $C$} ++(0:3) -- ++(300:0.5) node (C2in) {} -- ++(300:0.5) -- node[above] {$i{+}{+}$ if carried} ++(180:3) -- ++(120:0.5) node (C2out) {} -- ++(120:0.5);
}

\foreach \x in {3.5} {
\draw (\x, 0)++(300:5) -- ++(0:0.5) -- ++(300:0.5) node (Dhin) {} -- ++(300:0.5) -- ++(180:0.5) -- ++(120:0.5) node (Dhout) {} -- cycle; 
\draw (\x, 0)++(300:5.5)++(0:0.25) node {$D_h$};
}

\foreach \x in {1.5} {
\draw[thick, ->] (\x, 0)++(300:6)
-- ++(120:0.5) node (O2in) {} -- ++(120:0.3) -- ++(180:0.1) -- ++(300:0.8) -- ++(180:0.1)
-- ++(120:0.8) -- ++(180:0.1) -- ++(300:0.8) -- ++(180:0.1)
-- ++(120:0.8) -- ++(180:0.1) -- ++(300:0.8) -- ++(180:0.1)
-- ++(120:0.8) -- ++(180:0.1) -- ++(300:0.8) -- ++(180:0.1)
-- ++(120:0.9) -- ++(0:0.8) -- ++(120:0.2) node[draw, inner sep=0in] (O2m1) {}
;
\draw[thick,->] (O2m1)
-- ++(180:0.8) -- ++(120:0.1) -- ++(0:0.8) -- ++(120:0.1)
-- ++(180:0.8) -- ++(120:0.1) -- ++(0:0.8) -- ++(120:0.1)
-- ++(180:0.8) -- ++(120:0.1) -- ++(0:0.8) -- ++(120:0.1)
-- ++(180:0.8) -- ++(120:0.1) -- ++(0:0.8) -- ++(120:0.1)
-- ++(180:0.9) -- ++(300:0.8) -- ++(180:0.2) node[draw, inner sep=0in] (O2m2) {}
;
\draw[thick, ->] (O2m2) 
-- ++(120:0.8) -- ++(180:0.1) -- ++(300:0.8) -- ++(180:0.1)
-- ++(120:0.8) -- ++(180:0.1) -- ++(300:0.8) -- ++(180:0.1)
-- ++(120:0.8) -- ++(180:0.1) -- ++(300:0.8) -- ++(180:0.1)
-- ++(120:0.8) -- ++(180:0.1) -- ++(300:0.8) -- ++(180:0.1)
-- ++(120:0.9) -- ++(0:0.8) -- ++(120:0.2) node (O2out) {}
;
}

\foreach \x in {-1.5} {
\draw[thick, ->] (\x, 0)++(300:5) 
-- ++(120:0.5) node (A2in) {} -- ++(120:0.3) -- ++(180:0.1) -- ++(300:0.8) -- ++(180:0.1)
-- ++(120:0.8) -- ++(180:0.1) -- ++(300:0.8) -- ++(180:0.1)
-- ++(120:0.8) -- ++(180:0.1) -- ++(300:0.8) -- ++(180:0.1)
-- ++(120:0.8) -- ++(180:0.1) -- ++(300:0.8) -- ++(180:0.1)
-- ++(120:0.8) -- ++(180:0.1) -- ++(300:1) node[draw, inner sep=0in] (A2m1) {}
;
\draw[thick, ->] (A2m1) 
-- ++(0:0.8) -- ++(300:0.1) -- ++(180:0.8) -- ++(300:0.1)
-- ++(0:0.8) -- ++(300:0.1) -- ++(180:0.8) -- ++(300:0.1)
-- ++(0:0.8) -- ++(300:0.1) -- ++(180:0.8) -- ++(300:0.1)
-- ++(0:0.8) -- ++(300:0.1) -- ++(180:0.8) -- ++(300:0.1)
-- ++(0:0.8) -- ++(300:0.1) -- ++(180:1) node[draw, inner sep=0in] (A2m2) {}
;
\draw[thick, ->] (A2m2) 
-- ++(120:0.5) -- ++(120:0.3) -- ++(180:0.1) -- ++(300:0.8) -- ++(180:0.1)
-- ++(120:0.8) -- ++(180:0.1) -- ++(300:0.8) -- ++(180:0.1)
-- ++(120:0.8) -- ++(180:0.1) -- ++(300:0.8) -- ++(180:0.1)
-- ++(120:0.8) -- ++(180:0.1) -- ++(300:0.8) -- ++(180:0.1)
-- ++(120:0.8) -- ++(180:0.1) -- ++(300:1) node (A2out) {}
;
}
\draw(-1.25, 0)++(300:3.75) node {Turning module $T$};

\draw[-latex] (seedout) -- node[above right] {($i = j_1$, no carry) in \eqref{eq:turner_output}} (C1in);
\draw[-latex] (C1out) to [out=300, in=120] node[below right] {$i$ in \eqref{eq:counter_output}} (Dvin);
\draw(A1in)++(180:0.25)++(120:1) node[circle, draw, inner sep=0in] (AO1in) {};
\draw (Dvout) to [out=300, in=180] (AO1in);
\draw[-latex] (AO1in) to [out=0, in=120] node[below right] {($i$, A) in \eqref{eq:Dv_output}} (A1in);
\draw[-latex] (AO1in) to [out=0, in=120] node[above] {($i$, O) in \eqref{eq:Dv_output}} (O1in);
\draw (9.75, 0) ++(300:4) node (AO1out) {($i$, carry) in \eqref{eq:turner_output}};
\draw (A1out) to [out=210, in=150] (AO1out);
\draw (O1out) to [out=330, in=120] (AO1out);
\draw[-latex] (AO1out) to [out=300, in=0] (C2in);
\draw[-latex] (C2out) -- node[below] {$i$ in \eqref{eq:counter_output}} (Dhin);
\draw[-latex] (Dhout) -- node[above] {($i$, O) in \eqref{eq:Dh_output}} (O2in); 
\draw (0, 0)++(300:6.5) node (Dh-A2) {};
\draw[-latex] (Dhout) to [out=180, in=0] (Dh-A2) node[below] {($i$, A) in \eqref{eq:Dh_output}} to [out=180, in=0] (A2in);
\draw (-2, 0)++(300:1) node (AO2-C1) {($i$, carry) in \eqref{eq:turner_output}};
\draw (A2out) to [out=240, in=270] (AO2-C1);
\draw (O2out) to [out=150, in=270] (AO2-C1);
\draw[-latex] (AO2-C1) to [out=90, in=120] (C1in);

\end{tikzpicture}}
\caption{Module automaton for the Heighway dragon $P[j_1 .. j_2]$. 
Transitions are labeled with the information propagated with its format. 
}
\label{fig:module_automaton}
\end{figure}

\textit{Modularization} is a semantic factorization of transcript into functional units. 
Functions of modules and transitions from one module to another are described in the form of module automaton. 
The generic design employs the module automaton in Fig.~\ref{fig:module_automaton}.
This automaton yields the periodic transcript which repeats six modules of the following four types as $C D_v T C D_h T$:
\begin{itemize}
\item $C$ is a \textit{counter module}; it increments the count $i$ (index of $P$), which is ``initialized'' to $j_1$ on the seed, by 1 and propagates it; 
\item $D_v$ and $D_h$ are a \textit{DFAO module}; they compute $P[i]$ and interpret it properly (this issue of interpretation shall be discussed shortly); 
\item $T$ is a \textit{turning module}; it makes a turn according to the interpretation. 
\end{itemize}
The first $C$ and $D_v$ modules fold into a vertical line segment, while the second $C$ and $D_h$ fold into the next line segment, which is guaranteed to be horizontal since vertical and horizontal segments alternate on the Heighway dragon. 
The DFAO modules $D_v, D_h$ differ from each other only in their way to interpret their intermediate outcome $P[i]$. 
The slanted Heighway dragon involves two types of left turn as well as two types of right turn: acute and obtuse. 
Observe that after (slanted) vertical line segments, the dragon turns left obtusely and right acutely, whereas after horizontal ones, it turns left acutely and right obtusely. 
Therefore, it suffices for $D_v$ and $D_h$ to compute $P[i] \in \{{\rm L}, {\rm R}\}$ in the same way and $D_v$ interprets L as O and R as A, while $D_h$ interprets L as A and R as O. 

\begin{figure}[tb]
\centering
\includegraphics[width=0.8\linewidth]{Figs/dragon_vol5.png}
\caption{
Folding of one segment plus turn of the Heighway dragon, flow of information through it, and the two ways of collision avoidance between two turns.
}
\label{fig:abst_dragon}
\end{figure}

One issue intrinsic to the folding by OS rises when the dragon makes a turn where it has already turned before. 
The OS is, by definition, not allowed to put a bead anywhere occupied by another bead. 
Hence, the dragon must be scaled-up somehow. 
We employ the $c$-rhombus scaling for $c$ so large that a rhombus corresponding to a point affords two turning modules, which otherwise collide, as long as they fold into an L-shape (see Figs.~\ref{fig:heighway6_oritatami}, \ref{fig:module_automaton}, and \ref{fig:abst_dragon}). 
The turning module consists of three copies of a functional subunit that bifurcates $i$ while folding into a $c/3 \times c/3$ rhombus and guides the further folding in a way specified by the A/O signal fed by the previous DFAO module; acutely by A or obtusely by O as shown in Fig.~\ref{fig:abst_dragon} (also refer Figs.~\ref{fig:PFS} and \ref{fig:change_route}). 

Having outlined the generic design, now we explain how the design implements an OS for a specific target portion $P[j_1 .. j_2]$, or more precisely, how the modules $C, D_v, D_h, T$ and their submodules are implemented, interlocked with each other, and collaborate. 
Let $n = \min\{m \mid j_2 < 2^m\}$. 
%The length of $C, T$, or more precisely, of their transcript, are of length $O(n^2)$ while $D_v, D_h$ are of length $O(n)$. 
%Thus, the period of the OS is of length proportional to $n^2$. 
Each of the modules consists of submodules which are small, say, with several dozens of beads. 
Submodules implement various ``functions'' each of which is ``called'' in proper \textit{environments}, i.e., the beads already placed around the tip of the transcript acting as the memory in the computation. 
The conformation that a submodule folds deterministically in a ``valid'' environment corresponds to the function to be called then. 
These ``functional'' conformations are called \textit{bricks}, upon which the whole folding is built. 
\textit{Brick automata} describe the OS' behavior at submodule level by enumerating all the pairs of an environment to be encountered and the brick to be folded there as well as transitions among them. 
Once verified, all the brick automata for $C$ (resp. $D_v$, $D_h$, and $T$) guarantee that the module outputs in the expected format \eqref{eq:counter_output} (resp.~\eqref{eq:Dv_output}, \eqref{eq:Dh_output}, and \eqref{eq:turner_output}), and hence we can say that the DOS behaves as described in the module automaton and folds into $P[j_1 .. j_2]$. 
Using a simulator developed for \cite{HaKiOtSe2016}, we have verified all the brick automata. 
This amounts to the proof of Theorem~\ref{thm:main}. 

\begin{figure}[tb]
\includegraphics[width=\linewidth]{Figs/seed_sample2.png}
\caption{The seed for the 3-bit Heighway dragon that starts at $j_1 = 100_2$.}
\label{fig:seed}
\end{figure}

\paragraph{Seed} (Fig.~\ref{fig:seed}) encodes the initial count $i = j_1$ in its binary representation $b_n b_{n-1} \cdots b_1$ as the following sequence of bead types: 
\begin{equation}\label{eq:turner_output}
	{\tt 499 \east 500 \east 501 \east 506 \east 507 \east \mbox{$\bigodot_{k = n}^2$} (w_{t, b_k} \east 350 \east 351 \east (356 \east 357 \east)^6) w_{t, b_1}} 
\end{equation}
where ${\tt w_{t, 0} = 338 \east 339 \east 344 \east 345}$ and ${\tt w_{t, 1} = 346 \east 347 \east 348 \east 349}$. 

\paragraph{Counter module} $C$ is borrowed from \cite{GeMeScSe2016} with technical modification to let it operate in the dynamics \eqref{eq:cotranscriptional_folding}, which is more prevailing \cite{HanKim2017,HaKiOtSe2016,OtaSeki2017} though less tractable. 
%Hence, we just describe its input and output. 
It takes the current count $i$ formatted as \eqref{eq:turner_output}, which is fed by the seed or by the previous turning module, increments the count by 1 unless it is preceded by the seed, and outputs the resulting count in its binary representation $a_n a_{n-1} \cdots a_1$ in the following format:
\begin{equation}\label{eq:counter_output}{\tt 
	44 \east 45 \east 46 \east 51 \east 52 \east \mbox{$\bigodot_{k = n}^2$} (w_{c, a_k} \east (75 \east 76 \east)^5 51 \east 52 \east) w_{c, a_1}
}\end{equation}
where ${\tt w_{c, 0} = 57 \east 58 \east 63 \east 64 \east 69 \east 70}$ and ${\tt w_{c, 1} = 65 \east 66 \east 67 \east 68 \east 69 \east 70}$. 

\paragraph{DFAO modules $D_v, D_h$} receive the current count $i$ in the format \eqref{eq:counter_output} from the previous counter module, compute $P[i]$, and interpret it as A or O properly. 
The modules $D_v$ and $D_h$ then output the interpretation along with the count $i$ in the following formats, respectively: 
\begin{eqnarray}
& & {\tt \mbox{$\bigodot_{k=n}^2$} (w_{d, a_k} \east (52 \east 51 \east)^7) w_{d, a_1} \east 52 \east 51 \east 200 \east 199 \east w_{dv, P[i]}} \label{eq:Dv_output}\\
& & {\tt \mbox{$\bigodot_{k=n}^2$} (w_{d, a_k} \east (52 \east 51 \east)^7) w_{d, a_1} \east 52 \east 51 \east 311 \east 310 \east w_{dh, P[i]}} \label{eq:Dh_output}
\end{eqnarray}
where ${\tt w_{dv, L} = 198 \east 197}$, ${\tt w_{dv, R} = 194 \east 193}$, ${\tt w_{dh, L} = 305 \east 304}$, and ${\tt w_{dh, R} = 309 \east 308}$.

\begin{figure}[tb]
\includegraphics[width=\linewidth]{Figs/abst_DFAO.png}
\caption{Submodule-level abstraction of the folding of DFAO module.}
\label{fig:abst_dfao}
\end{figure}

What the DFAO in Fig.~\ref{fig:heighway_dragon} really does for computing $P[i]$ is to search for the first 0 from the LSB and check if it is followed by 0 ($P[i] = {\rm R}$) or by 1 ($P[i] = {\rm L}$). 
See Fig.~\ref{fig:abst_dfao}. 
$D_v$ (resp.~$D_h$) employs the six submodules: {\tt Dzig1}, \texttt{Dzag1}, \texttt{Dzig2}, \texttt{Dzag2}, \texttt{PFS}, and $\mathtt{AO}_v$ (resp.~$\mathtt{AO}_h$), which are interleaved by spacers, as well as those that guide the transcript into two zigzags and one more zig (throughout the paper, zigs are to go leftward while zags are to go rightward). 
The first zigzag is for the search, the second is for the check and computation of $P[i]$, and the third zig is for the interpretation of $P[i]$ as A/O. 
While performing these tasks, these zigs and zags also propagate the count $i$ to the next turning module. 

\begin{wrapfigure}[15]{r}{0.6\linewidth}
\vspace*{-5mm}
\centering
\includegraphics[width=\linewidth]{Figs/DFAO-zig1.png}  
\caption{The four bricks of \texttt{Dzig1}: (top) Dzig1-1 and Dzig1-f0; (bottom) Dzig1-20 and Dzig1-21.}
\label{fig:DFAO-zig1}
\vspace*{-3mm}
\end{wrapfigure}

In the first zig, $n$ copies of \texttt{Dzig1} detect the first 0 collaboratively in two phases. 
See Fig.~\ref{fig:DFAO-zig1} for all the bricks of \texttt{Dzig1} with the corresponding environments. 
Phase 1 is to copy all the 1's prior to the first 0 and Phase 2 is to copy all the bits after the 0. 
\texttt{Dzig1} knows which phase it is in by the relative position to start folding to the input above (top in Phase~1, bottom in Phase~2). 
In Phase~1, \texttt{Dzig1}s certainly fold into the brick Dzig1-1. 
At the first 0, a \texttt{Dzig1} rather folds into Dzig1-f0 brick, ending at the top in order to transition to Phase 2. 
Each of the remaining \texttt{Dzig1} folds into either Dzig1-20 or Dzig1-21, copying all the remaining bits. 
Interleaving spacers are implemented as a glider (see Sect.~\ref{sect:preliminaries}), hence capable of propagating 1bit (top/bottom) on which phase the system is in. 
In the first zag, $n$ copies of \texttt{Dzag1} reformat and propagate 0's, 1's, and the first 0 using three bricks. %using the three bricks in Fig.~\ref{fig:Dzag1}.

In the second zig, $n$ copies of \texttt{Dzig2} check whether the first 0 is followed (being read from LSB) by 0 or 1, in a similar manner to the search in the first zig. 
They usually take one of the two bricks Dzig2-0 and Dzig2-1 to copy 1's and 0's, which start and end at the bottom. % (see Fig.~\ref{fig:Dzig2}).
At the encounter to the first 0, a \texttt{Dzig2} folds into a special brick Dzig2-f0 and ends rather at the top. 
The next \texttt{Dzig2}, if any, starts folding at the top so that it takes the special brick Dzig2-1f0 if it is followed by 1 or Dzig2-0f0 otherwise. 
Recall the reading 1 here is a necessary and sufficient condition for $P[i] = {\rm L}$. %the DFAO in Fig.~\ref{fig:heighway_dragon} to transition to $q_2$, that is, $P[i] = {\rm L}$. 
Dzig2-1f0 exposes a marker $q_2$ downward. 
These bricks end at the bottom so that the remaining bits are copied by the ordinary bricks Dzig2-0 and -1. 
The second zag starts at the bottom and copy 0's and 1's by two bricks of \texttt{Dzag2} until a \texttt{Dzag2} encounters the 1 marked by $q_2$, if any. 
At the encounter, the \texttt{Dzag2} folds into the special brick Dzag2-T1 and changes the ending position to the top, letting the remaining \texttt{Dzag2} rather fold into the bricks Dzag2-L0 and -L1 for copying, which end at the top. 
As such, the second zag can feed $P[i]$ to \texttt{PFS} as the position of its first bead. 

\begin{figure}[tb]
\centering
\includegraphics[width=\linewidth]{Figs/PFS.png}
\caption{The two bricks of \texttt{PFS} above and the corresponding two bricks of (left) $\mathtt{AO}_v$ and (right) those of $\mathtt{AO}_h$.}
\label{fig:PFS}
\end{figure}

At the beginning of the third zig, $D_v$ employs $\mathtt{AO}_v$ to convert $P[i]$ into ${\tt w_{dv, P[i]}}$ while $D_h$ employs rather $\mathtt{AO}_h$ to convert $P[i]$ into ${\tt w_{dh, P[i]}}$. 
The turning module interprets ${\tt w_{dv, L}}$ and ${\tt w_{dh, R}}$ as turning obtusely while ${\tt w_{dv, R}}$ and ${\tt w_{dh, L}}$ as turning acutely. 
As a part of effort to save bead types, the submodule $\mathtt{AO}_v$ is also diverted in order for both $D_v$ and $D_h$ to propagate $i$ in the rest of this zig. 

\begin{wrapfigure}[8]{r}{0.5\linewidth}
\vspace*{-7mm}
\centering
\includegraphics[width=\linewidth]{Figs/turn-rgp.png}
\caption{The two bricks of \texttt{turn-rgp}.}
\label{fig:turn-rgp}
\end{wrapfigure}

\paragraph{Turning module} $T$ consists of 3 copies of the pair of two functional units called \textit{bit-bifurcator} and \textit{steering arm}. 
See Fig.~\ref{fig:turner}. 
The bit-bifurcator forks the count $i = a_n a_{n-1} \cdots a_1$ left and rightward while folding into zigzags. 
It consists of 10 submodules, which handle the following tasks: 
\begin{enumerate}[topsep=0in, itemsep=0in]
\item Propagate 1-bit vertically: {\tt body-rpx1}, {\tt body-rpx2}, {\tt body-lpx1}, {\tt body-lpx2}; 
\item Let 1-bit propagating vertically cross another 1-bit propagating horizontally: {\tt body-gx1}, {\tt body-gx2}; 
\item Fork 1-bit vertically and horizontally: {\tt body-rgy}, {\tt body-lgy}; 
\item Undergo transition between a zig and a zag and exposes 1-bit outside: {\tt turn-rgp}, {\tt turn-lgp}. 
\end{enumerate}
Submodules to handle the first two types of tasks have already been implemented (see, e.g., \cite{HaKiOtSe2016}). 
The submodule \texttt{body-rgy} is implemented by recycling the first half of \texttt{Dzag2}.  %(Fig.~\ref{fig:Dzag2}). 
Starting from the bottom, it can take two conformations that end at different heights and expose sequences bead types distinct enough downward. 
The 1-bit thus forked transfers till the end of a zag and is converted into a sequence of bead types by \texttt{turn-rgp} (Fig.~\ref{fig:turn-rgp}). 
The submodules \texttt{body-lgy} and \texttt{turn-lgp} are the zig-counterparts of them. 

\begin{figure}[tb]
\centering
\includegraphics[width=\linewidth]{Figs/overall_turn_part.png}
\caption{Submodule-level abstraction of the whole folding of the pair of a bifurcator and steering arm. 
All the white submodules are spacers, some of which are implemented in the shape of parallelogram instead of glider.}
\label{fig:turner}
\end{figure}

\begin{figure}[tb]
\centering
\includegraphics[width=0.9\linewidth]{Figs/change-route.png}
\caption{The two bricks of \texttt{change-route}.}
\label{fig:change_route}
\end{figure}

The bifurcator also propagates the 1-bit A/O signal, output by the previous DFAO module, to let the steering arm know which way to go. 
Specifically, the signal has the \texttt{change-route} submodule of the steering arm take one of the two bricks shown in Fig.~\ref{fig:change_route}, guiding the rest of the arm towards the specified direction. 
The rest of the arm is a catenation of \texttt{move} submodules, which is capable of letting the bifurcated bit sequence through. 
Note that the turning module does not have to bifurcate the A/O signal. 
Indeed, the second and third pairs of bifurcator and steering arm are supposed to turn in the same manner as the first. 
It hence suffices to append A and O to the bifurcated bit sequences on the acute and obtuse sides, respectively. 

%--------------------------------------------------------------------------------------------------------
	\section{Conclusion}
%--------------------------------------------------------------------------------------------------------

In this paper, we proposed a generic design of oritatami systems for an arbitrary finite portion of Heighway dragon. 
One down side is that the scaling factor depends on the length of the portion, though just logarithmically. 
It is hence of significant interest whether the dependency is necessary. 
Should it not be, we could implement an OS that folds into the real (infinite) Heighway dragon. 

\paragraph{Acknowledgements} 
We would like to thank Hwee Kim for valuable discussions. 

%--------------------------------------------------------------------------------------------------------
	\bibliographystyle{splncs03}
	\bibliography{heighway_CIAA2018}
%--------------------------------------------------------------------------------------------------------

\end{document}
