前説

page2
〜セントラルドグマの話〜
私たちの体の中ではdnaからrna、rnaからタンパク質へと情報が伝達されます。この一連の流れをセントラルドグマと呼びます。この中のdnaからrnaへの流れを転写と呼びます。
Dnaとrnaの鎖はa,t,c,g、a,u,c,gの塩基で構成されています。これらの塩基はau,cg,at間で水素結合を結びます。rnaの鎖は転写の際、これらの塩基間で水素結合を結ぶことで安定した二次構造へと折りたたみます。これをcfと呼びます。

page3
〜どのように酵素が使われて転写が行われるか〜
この図はRNAがどのように転写されるかを示しています。
黄色い二重鎖がDNAです。このDNAにRNA polymeraseがくっつき、鎖を解き、周辺から材料を集め、相補的なRNAを合成していきます。

page4
〜動画を使いながらCFの話〜
これはその様子のイメージです。
動画を見て見ましょう。
ご覧の通りに、RNAの鎖にRNAぽlyがくっつきます。
そしてDNAを読みながらRNAぽlyがRNAを転写していきます。
この時に見てわかる通り、RNA間で水素結合を取ることでRNAは安定した構造に折り畳まれていきます。
このように転写と折りたたみが同時に行われる現象をCFと呼びます。

page5
〜実世界でRNAは周辺の状況によって構造の変化させて、能力を発現させてるって話〜
CFの特製の一つとして周りの環境によって折りたたまり方が変わるということがります。
この場合、NaFの濃度によって折りたたみ方を変えます。
折りたたみかたが変わったことで異なる振る舞いをします。
このCFは私たちの体の中で実際に起きています。

page6
〜RNA Origamiの話〜
Gearyらは鋳型となるDNA鎖を適切に設計することで転写されるRNAを一意にタイルの形に折り畳ませることに成功しました。
この技術をRNA origamiと言います。
今はまだCFでRNAで作れる構造はタイルしかありません。
他にどのような構造が作れるのか、またCFにはどれくらい計算能力があるのか、研究するためにOSという数理モデルが提唱されました。

page7
~OS使ったよって話~
〜
Oritatami system is a mathematical model of computation by cotranscriptional folding.
It abstracts RNA structure as 2-dimensional directed path over the triangular grid with interaction.
〜
私たちはこのOSを使ってCFで他にどのような構造を作れるかということを研究しています。

page8
〜CFでフラクタルを描写を行なったよって話〜
このOSでの構造の研究として私たちはフラクタル構造の作成に取り組みました。
本論文で私たちが作った構造はこのheighway Dragonと呼ばれるフラクタルです。
このフラクタルを選んだ理由は
１.一筆書きができOSと親和性がある（ガバガバ）
２.フラクタルは非周期的であるから〜〜〜（次ページの感じ）

page9
研究のモチベーションの話
・計算能力の研究ばかりされて来たがshapeの研究がされてこなかった
→初のshape研究を行なった
・フラクタルを作るってのは分子組織化理論ではベンチマークになっている

・フラクタルは非周期的な構造なので何かしらの計算を行いながら構造を作る必要がある
ー→既存の計算能力とshapeの研究を組み合わせられる

％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％
％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％
OS、brickの説明

page10
これからOSの説明を始めます。
先ほど説明した通り、OSは三角格子状で動きます。

page11
OSは次のように定義されています。
OSは6つ組で表されます。
シグマは〜


page12
では動作例をみていきましょう。
wは〜、Rは〜デルタは〜、シードは〜
d＝３なので３つのビードが転写され折り畳まれます。
OSは最も安定した構造へと折り畳まれます。
なのでもっとも水素結合を多くとる構造へと折り畳まれます。
今回の場合はこの構造なので、最初のbが固定されます。
そして新たにビードが一つ転写されます。
同じように折りたたみを探してnextのcが固定されます。
and so on 
このようにOSはどうさします。

page13
CFは周りの環境で折り畳まりを変えます。OSではどのように変わるのか例を見ましょう。
w,R,dは先ほどと同じです。
ただしseedのこの部分にaというビードが配置されています。
ではみていきましょう。
（さっきと同じ感じ）
（cを固定する時）この水素結合によってCの配置されるがさっきと変わります。
and so on
最終的な構造がこのように変わりました。
このcontext-sensitiveの性質を使ってOSは情報を処理します。
どのように既存研究では情報を処理してきたかみてみましょう。

page14
これは既存研究のOSでバイナリカウンタを実装した時に使われたサブシーケンスです。
このサブシーケンスは周りの環境、この場合、サブシーケンスが始まる位置と上部に現れている高分子の種類によって、図のように４つの異なる構造に折り畳まれます。
これによりこのサブシーケンスは、half adderの機能を持たせています。
入力として、スタートの位置が上か下かでcarryのOnOffを、上に位置する高分子の種類で０１を与えます。
そして出力として、折り畳まりの終わりの位置が上か下かでcarryのOnoffを、下に位置する高分子の種類で０１を出力します。
このようにある機能を持たせたサブシーケンスを私たちはbrickと読んでいます。
このbrickを組み合わせることでより複雑な機能を処理するものをモジュールと呼びます。
このモジュールでOSで複雑な計算を行うことができます。

page15
ではこのbrickを使ってどのように数をカウントしているかみていきましょう。
（ここでカウンタmoduleの説明）

page16
これは実際の図です。
このようにmoduleはzigzagしながら積み重なるようにwを設計することでOSは情報処理を行なっています。

page17
ここからはどのようにHeighway DragonをOSで実装したか説明します。

page18
highway dragonは片方の先端から順に各角が右左に折れているかをRLで書き表すとPという数列で表すことができます。このPはDFAOを使って計算することができます。
（読む）

page19
このようにDFAOでpeperholdingが計算できるか見ていきましょう。
the i th … （読む）

このように0から入力を続ければPが得られます。

なのでカウンタとDFAOとDFAOの出力によって右左に折り曲がる構造を作ればOSでHDが作れるだろうと考えました。

page20
OSは三角格子状で動作するので図のような傾いた形のHDを実装するのが自然であると考えました。

で、実装するにあたり２つの問題がありました。
１つ目がOSは一度固定されたビードの上に他のビードを配置することはできないが、HDは同じ頂点に度々戻ってきます。この衝突の問題がありました。
この問題はスケーリングによって解決しました。
二つ目の問題が、HDが傾いていることによって４種類のターンが発生することです。
しかし、次の性質、（veritical lineの場合L->O、R→A、horizontal なら逆、に折り曲がる）があるので
DFAOの出力をAOの情報に変換することで、AOのふた方向に曲がるTruning moduleで折り曲がりを実装した。

page21
以上のことからHDを書くにあたって次のアルゴリズムをOSで実装しました。
はじめ、i=0に設定し、iを伝達しながら以下のことを繰り返しました。

transcriptはこれの繰り返しです。
（読むだけ）
このトランスクリプトの繰り返しをOSに与えました。

page22
各モジュールのつながりは次のようになっています。
（各モジュールのつながりを軽く）

page23
次はそれぞれの部分をどのように構成したか見ていきましょう
（seedの説明ぶんを読む）

page24
前ページのようにイニシャライズされた０、１という情報はこの図のようにpropagateされながらHDを描いていきます。
(ここでCDvTモジュールの情報伝達の流れ、およびにturner を次のように設計することによってコリジョンを解決しています。)

図のカウントアップしているところとコピーの部分は既存研究のhalfadderのモジュールを参考にしました。
half adderは既存のものとrulesetが少し違いますが基本設計は同じなので説明を省略します。
この部分では線分を描くはじめのジグザグのみcarryを与え、i++して、それ以降はcarryを与えないことでiをpropagateしながらHDの描いています。

次に私たちが設計したDFAOとTurnerをどのように設計したかを説明します。
page25
OSはAutomatonと違い記憶領域をもちません
なので私たちはこのAutomatonを実装するにあたり工夫する必要がありました。
工夫というのはこのautomatonの形を利用するものです。
このDFAOは見てわかる通り、LSBから読んでfirst0の後が１がある時のみq2に遷移してLが出力されます。
それ以外の場合はRが出力されます。
そこで私たちはfirst0の１がくるのか、それ以外なのかをチェックする機構をDFAOmoduleとして実装しました。
この処理はこのmoduleは２回のジグザグで計算します。
１回目のジグザグで〜
２回目のジグザグで〜

page26
DFAOから送られてきたi+AOの情報をこれらの様々なsmall moduleを組み合われることによって点線のように左右と下の３方向に情報を分岐させて伝達される構造を作りました。
情報を３方向に伝達した後、ここ（右下を刺しながら）に送られてきたA  or Oという情報に従って、青の小moduleが構造を変えて、acute方向かobtuse方向に伸長していくかを制御しています。
これが３つ組み合わさってturning moduleは構成されています。

これらを組み合わせてHDを私たちは作りました。
page27
最後に私たちはこのHDがきちんと動作することを証明するために次のようなbrick automataを作りました。
これは各brickが取りうる環境を記述し、brickのconformationの変化によって次にどのような環境に遷移するかを表したものです。
これを全てのbrickについてbrick automataを作り、HDで取りうる全ての環境を列挙しました。
そのそれぞれ状況をPCでシミュレートして、正しく動作していることを確認しました。
このシミュレータはwebで公開されていて誰でも確認することができます。
以上のことでHDが正しく実装されていることを証明しました。

page28
これが私たちが作り上げたHDです。

以上です。










%%%%%%%%%%%%%
実装部分で話さなくてはならないこと

OSはautomatonと違い記憶領域を持たない
→どのように工夫して記憶したのかの説明がciaa(automatonのアプリケーションの学会)では大切 

%%%%%%%%%%%%%

DFAOの説明のあと






